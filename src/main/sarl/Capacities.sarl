import java.util.List
import java.util.Map
import java.util.TreeMap
import java.util.UUID
import org.arakhne.afc.math.continous.object2d.Point2f
import tx52.environment.AgentBody
import tx52.environment.EnvMap
import tx52.environment.EnvironmentObject
import tx52.environment.RTree


/**
 * @author Olivier
 *
 */
 /** Capacity to manage the map */
capacity MapManager {
	/** Replies the number of bodies in the map */
	def getBodyCount : int
	
	/** execute the list of influences 
	 * 	@return true if game is over? *TBD* */
	def resolveInfluences (influences : List<Influence>) : boolean
	
	/** replies the perceptions */
	def getPerceptions : Map<AgentBody, List<EnvironmentObject>>
	
	/** replies the width of the map. */
	def getMapWidth : float
	
	/** replies the height of the map. */
	def getMapHeight : float
	
	/** replies all the objects */
	def getAllObjects : RTree
	
	/** Replies a specific body */
	def getAgentBody(id : UUID) : AgentBody
	
}


capacity EndOfTurn {
	def sendPerception(time : float, bodyID : UUID, objects : List<EnvironmentObject>,position : Point2f)
	
}


skill DefaultMapManagerSkill implements MapManager {
	
	val width : float
	val height : float
	
	/** EnvMap or environment?? */ 
	var map : EnvMap
	
	new (width : float, height : float) {
			this.width = width
			this.height = height
	}
	
	override install {
		/**where is the constructor of the map according to its size? */
		this.map = new EnvMap(null)
	}
	
	override getBodyCount : int {
		/** create a method to get size of the objectlist */
		/** this.map.getObjectList().size()*/
		0
	}
	
	override resolveInfluences(influences : List<Influence>) : boolean {
		/**var expectedMotions = new TreeMap
		for (i : influences) {
			var body = this.map.getAgentBody(i.emitter)
			var newPosition : Point2f
			if(i.change != null) {
				newPosition = body.position + i.change.toVector
			} else {
				newPosition = body.position.clone
			}
			if (newPosition == body.position || this.map.canMoveInside(newPosition.x,newPosition.y)) {
				var l = expectedMotions.get(newPosition)
				if (l == null){
					l = newArrayList
					expectedMotions.put(newPosition, l)
				}
				l+=body
			}
			
		}
		/**A partir de là je comprends pas */
		/** var resolvedMotions = new TreeMap
		for (change : expectedMotions.entrySet) {
			
		}*/
		false
	}
	
	/**
	 * calcul de toutes les perceptions -> utile seulement pour le général
	 */
	override getPerceptions : Map<AgentBody, List<EnvironmentObject>> {
		var perceptions = new TreeMap
		for (body : this.map.agentBodies) {
			var percepts = newArrayList
			var d = body.perceptionDistance
			var p = body.position
			var obj = this.map.getObjectAt(p.getX(),p.getY(),d)
			if (obj != null){
				percepts += obj
			}
			perceptions.put(body, percepts)
		}
		return perceptions
	}
	
	override getMapWidth : float {
		this.width
	}
	
	override getMapHeight : float {
		this.height
	}
	
	override getAllObjects : RTree {
		this.map.getObjectList()
		
	}
	
	override getAgentBody(id : UUID) : AgentBody {
		// TODO Auto-generated action.
		this.map.getAgentBody(id)
	}
	
}

/** Skill for being the front-end of a maze.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
skill DefaultEndOfTurnSkill implements EndOfTurn{
	
	
	override sendPerception(time : float, bodyID : UUID, objects : List<EnvironmentObject>, position : Point2f) {
		var p = new Perception(time, bodyID, objects, position)
		//how to notify perception 
	}
	
}