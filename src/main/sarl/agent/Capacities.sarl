package ^agent

import java.util.List
import java.util.Map
import java.util.UUID
import org.arakhne.afc.math.continous.object2d.Point2f
import tx52.environment.AgentBody
import tx52.environment.EnvMap
import tx52.environment.EnvironmentObject
import tx52.environment.RTree
import tx52.environment.Environment
import tx52.gui.Window
import tx52.environment.Perceivable
import java.util.ArrayList
import io.sarl.core.DefaultContextInteractions
import tx52.environment.EnvironmentChangeQuery
import java.util.TreeMap
import org.arakhne.afc.math.continous.object2d.Vector2f
import io.sarl.util.Scopes
import org.jbox2d.common.Vec2
import tx52.environment.StaticObject

/**
 * @author Olivier
 *
 */
 
 /** Capacity to manage the map */
capacity MapManager {
	/** Replies the number of bodies in the map */
	def getBodyCount : int
	
	/** execute the list of influences 
	 * 	@return true if game is over? *TBD* */
	def resolveInfluences (actions : List<EnvironmentChangeQuery>) : boolean
	
	/** replies the perceptions */
	def sendPerceptions (time : float)
	
	/** replies the width of the map. */
	def getMapWidth : float
	
	/** replies the height of the map. */
	def getMapHeight : float
	
	/** replies all the objects */
	def getAllObjects : RTree
	
	/** Replies a specific body */
	def getAgentBody(id : UUID) : AgentBody
	
	/** Create basic Unit */
	def createUnit(perceptionDistance : float) : AgentBody
	
	/** Create the map surroundings walls */
	def createMapSurroundings
	
	def updateTree
	
	def RunJbox
	
	def updateWindow
	
	def printTree

	def SpawnButtonRequest : boolean
	
}


capacity EndOfTurn {
	def sendPerception(time : float, bodyID : UUID, objects : ArrayList<Perceivable>,position : Point2f)
	
}


skill DefaultMapManagerSkill implements MapManager {
	
	uses DefaultContextInteractions
	
	val width : float
	val height : float
	
	var environment : Environment
	var GUI : Window
	
	new (width : float, height : float) {
			this.width = width
			this.height = height
	}
	
	override install {
		/**where is the constructor of the map according to its size? */
		this.environment = new Environment(this.width,this.height)
		GUI = new Window(this.environment)
	}
	
	override getBodyCount : int {
		/** create a method to get size of the objectlist */
		 return this.environment.world.getBodyCount()
	}
	
	override resolveInfluences(actions : List<EnvironmentChangeQuery>) : boolean {
		
		for( change : actions){
			var body = getAgentBody(change.getEmitter).getBody()
			var velocity = change.getVelocity
			var force = new Vec2(/*velocity.getX(),velocity.getY()*/2,1)
			body.setLinearVelocity(force)
			//print("test")
		}
		
		RunJbox // 1 step of simulation	
		
		false
	}

	/**
	 * calcul de toutes les perceptions -> utile seulement pour le général
	 */
 	override sendPerceptions(time : float) {
		
		for (body : this.environment.world.agentBodies) {
			
			
			var percevaibles = newArrayList
			percevaibles = body.computePerception
			var pos = body.position
			
			var perceptionEvent = new Perception(time,body.getId,percevaibles,pos,body)
//			System.out.printf("\nPerception de l'UUID : "+body.getAgentId()+"\ntime: "+time+" position: " +pos);
//			System.out.printf("\nPercevaibles :\n");
//			for(per : percevaibles){
//				System.out.printf("object : "+per+"\n")
//			}
			var adr=defaultSpace.getAddress(body.getId)
			emit(perceptionEvent ,Scopes::addresses(adr))

		}
		
	}
	
	override getMapWidth : float {
		this.width
	}
	
	override getMapHeight : float {
		this.height
	}
	
	override getAllObjects : RTree {
		this.environment.world.getObjectList()
		
	}
	
	override getAgentBody(id : UUID) : AgentBody {
		// TODO Auto-generated action.
		this.environment.world.getAgentBody(id)
	}
	
	override createUnit(perceptionDistance : float) : AgentBody {
		// TODO Auto-generated action.
		this.environment.world.createBody(typeof(AgentBody),null,this.environment.getjBoxWorld(),perceptionDistance)
	
	}
	
	override createMapSurroundings {
		var id : UUID
		id = UUID.randomUUID()
		var objects = <EnvironmentObject>newArrayList(new StaticObject(10,100,20,200,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(100,5,200,10,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(190,100,40,200,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(100,180,200,40,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(20,86,40,20,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(80,10,10,30,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(170,90,50,10,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(95,170,10,60,id,environment.getjBoxWorld,environment.getWorld()))
		id = UUID.randomUUID()
		objects.add(new StaticObject(93,73,6,6,id,environment.getjBoxWorld,environment.getWorld()))
		this.environment.addObjectToWorld(objects)
	}
	
	override RunJbox {
		
		this.environment.runJBox()
	}
	
	override updateWindow {
		
		this.GUI.updateWindow()
	}
	
	override printTree {
		//this.environment.printMap()
	}
	 
	override updateTree {
		this.environment.updateTree()
	}
	
	override SpawnButtonRequest : boolean {
			if (!this.environment.getEventFire().isEmpty()){
				this.environment.getEventFire().poll()
				return true;
			}
			return false;	
	}
	
}

/** Skill for being the front-end of a maze.
 * 
 */
/*skill DefaultEndOfTurnSkill implements EndOfTurn{
	
	uses DefaultContextInteractions
	
	
	override sendPerception(time : float, bodyID : UUID, objects : ArrayList<Perceivable>, position : Point2f) {
		var p = new Perception(time, bodyID, objects, position)
		
	}
	
}*/

capacity PhysicEnvironment {
	
	/** Invoked to send the influence to the environment.
	 * 
	 * @param linearInfluence is the linear influence to apply on the object.
	 * @param angularInfluence is the angular influence to apply on the object.
	 */
	def influenceKinematic(linearInfluence : Vector2f = null, angularInfluence : float = 0f)
	
}