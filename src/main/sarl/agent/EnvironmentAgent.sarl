package ^agent

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.Scopes
import tx52.environment.EnvironmentListener
import tx52.environment.EnvironmentChangeQuery
import tx52.environment.AgentBody
import java.util.List
import java.util.UUID
import io.sarl.lang.core.Address

/**
 * @author Olivier
 * 
 */
 
agent EnvironmentAgent { 
	
	uses DefaultContextInteractions, Lifecycle
	uses MapManager, EndOfTurn, Logging
	
	var listeners = <EnvironmentListener>newArrayList
	var time = 0.0f
	var Dt = 1.0f //DeltaT
	val actions = <EnvironmentChangeQuery>newLinkedList
	var adr : Address
	var spaceID : UUID
	var countInit = 0
	val agentNumber = 12
	
	on Initialize{
		
		spaceID = defaultSpace.getID.getID
		adr=defaultSpace.getAddress(this.ID)
		
		//we create the environment *in the skill*
		setSkill(typeof(MapManager), new DefaultMapManagerSkill(200,200))
		createMapSurroundings
		//we create the objects -> need to link the agents
		for (var i=0;i<agentNumber;i++) {
			var body = createUnit(10)
			var agentParameters : List<Object> = newArrayList(spaceID,this.getID/*BehaviorType */)
			var agentType = AgentTest//AgentBody.AgentType //semantique de l'agent
			spawnInContextWithID(
				agentType,
				body.getAgentId,
				defaultContext,
				agentParameters.toArray)
		}
		
		updateWindow //mis a jour de la vue utilisateur
		fireEnvironmentChange //utile ?
		
	}
	/**
	 * make a copy of the environment and send it to the GUI + wake up all listeners
	 */
	def fireEnvironmentChange {
		/*var objects = new TreeMap<Point,EnvironmentObject>
		for (obj : getEnvironmentObjects) {
				objects.put(obj.position,obj)
		}
		var ^event = new EnvironmentEvent (ID, this.time, mapWidth, mapHeight, Collections::unmodifiableMap(objects))
		for (listener : this.listeners) {
			listener.EnvironmentChanged(^event)
		}*/
	}
	
	on agentReady {
		synchronized(this) {
			countInit++
			if(countInit==agentNumber){
				emit(new RunBeginingOfStep,Scopes::addresses(adr))
			}
			
		}
	}
	
	on Influence [occurrence.time >= time] {
		synchronized(this) {
			this.actions += new EnvironmentChangeQuery(occurrence.source.getUUID,occurrence.vector)
			
			if (this.actions.size >= bodyCount - 1) {
				emit(new RunEndOfStep,Scopes::addresses(adr))
			}
		}
	}

	/** 
	* initialize the turn (update world state, give perceptions to AI, fire all the agents, *increase time) *or in endOfStep 
	*/
	on RunBeginingOfStep {
		
		//TODO write RunBeginingOfStep

		synchronized(this){
				if (this.actions.size() > agentNumber)
					this.actions.clear()
				sendPerceptions(this.time) // Perception computation
				//execution de tous les agents
				//récupération des influences -> processus parallele
				//resolveInfluences(actions)
			
		}
	}
	
	/**
	 * 
	 * update world state, update the position of all objects, move to next step
	*/	
	on RunEndOfStep {
		
		synchronized(this) {

			//envoie des influences vers Jbox
			resolveInfluences(actions)
			
				//update Tree
			updateWindow //mis a jour de la vue utilisateur -> ça fait clignoter
			printTree //debug
			
			time+=Dt
			emit(new RunBeginingOfStep,Scopes::addresses(adr))
		}
	}
	
		
	def fireGameOver {
		for (listener : this.listeners) {
			listener.gameOver()
		}
	}
}